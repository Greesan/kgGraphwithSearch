# Tab Clustering Implementation

This document describes the tab clustering implementation with centroid-based assignment.

## Overview

The tab clustering system automatically organizes browser tabs into semantic groups based on content similarity. It uses OpenAI embeddings and centroid-based similarity matching to efficiently cluster tabs.

## Key Design Decisions

### 1. Centroid Updates on BOTH Add and Remove

**Decision**: Update cluster centroids when tabs are added OR removed.

**Rationale**:
- Prevents the "ghost cluster" problem where new tabs are compared against stale centroids that include deleted tabs
- Ensures accurate tab assignment based on current cluster composition
- Performance cost is negligible (~0.1ms for centroid recalculation)

**Example**:
```python
# Initial cluster: Mixed React + Vue tabs
cluster = TabCluster(tabs=[react1, react2, vue1, vue2])
cluster.centroid = mean([react1, react2, vue1, vue2])  # Mixed centroid

# Remove all Vue tabs
cluster.remove_tab(vue1.id)
cluster.remove_tab(vue2.id)
cluster.update_centroid()  # Now pure React centroid

# New Vue tab should NOT match pure React centroid
new_vue_tab = Tab(title="Vue Router")
similarity = cosine_similarity(new_vue_tab.embedding, cluster.centroid)
# similarity < threshold (correctly rejected)
```

### 2. Rename Triggered ONLY by Additions

**Decision**: Cluster rename is triggered only when enough new tabs are added, NOT when tabs are removed.

**Rationale**:
- Additions indicate cluster evolution (new content/focus)
- Removals indicate cluster reduction (user pruning/cleanup)
- Removing tabs doesn't change the cluster's semantic theme

**Implementation**:
```python
def add_tab_to_cluster(self, cluster: TabCluster, tab: Tab):
    cluster.add_tab(tab)
    cluster.update_centroid()  # Always update

    # Check rename threshold (only for additions)
    if cluster.tabs_added_since_naming >= self.rename_threshold:
        cluster.name = self.generate_cluster_name(cluster)
        cluster.tabs_added_since_naming = 0  # Reset counter

def remove_tab_from_cluster(self, cluster: TabCluster, tab_id: int):
    cluster.remove_tab(tab_id)
    cluster.update_centroid()  # Always update
    # NO rename triggered here
```

### 3. Cluster Deletion for Small Clusters

**Decision**: Automatically delete clusters that drop below 2 tabs.

**Rationale**:
- A cluster with 0-1 tabs is not meaningful
- Prevents cluttering the UI with "empty" or single-tab clusters
- User can re-cluster remaining tabs if needed

**Implementation**:
```python
def remove_tab_from_cluster(self, cluster: TabCluster, tab_id: int):
    removed = cluster.remove_tab(tab_id)

    if removed:
        cluster.update_centroid()

        # Delete cluster if too small
        if cluster.tab_count < 2:
            self.clusters.remove(cluster)
```

### 4. Similarity Threshold

**Decision**: Use configurable similarity threshold (default: 0.75) for cluster assignment.

**Rationale**:
- Higher threshold = stricter clustering (fewer, more focused clusters)
- Lower threshold = looser clustering (more, broader clusters)
- Default of 0.75 balances precision and recall

## Architecture

### Core Classes

#### `Tab` (models.py)
Represents a browser tab with metadata and embedding.

```python
@dataclass
class Tab:
    id: int
    url: str
    title: str
    embedding: list[float]  # 1536-dim from text-embedding-3-small
    entities: list[str]
    created_at: datetime
```

#### `TabCluster` (models.py)
Represents a cluster of related tabs.

```python
@dataclass
class TabCluster:
    id: str
    name: str  # Generated by LLM
    color: ClusterColor
    tabs: list[Tab]
    centroid_embedding: list[float]
    tab_count: int
    tabs_added_since_naming: int
    _centroid_dirty: bool  # Internal flag

    def update_centroid(self):
        """Recalculate centroid from current tabs."""
        embeddings = [tab.embedding for tab in self.tabs]
        self.centroid_embedding = np.mean(embeddings, axis=0)
```

#### `TabClusterer` (tab_clusterer.py)
Main clustering service.

```python
class TabClusterer:
    def __init__(
        self,
        similarity_threshold: float = 0.75,
        rename_threshold: int = 3,
    ):
        self.similarity_threshold = similarity_threshold
        self.rename_threshold = rename_threshold
        self.clusters = []

    def process_tab(self, tab: Tab) -> TabCluster:
        """Assign tab to best cluster or create new one."""
        result = self.find_best_cluster(tab)

        if result:
            cluster, similarity = result
            self.add_tab_to_cluster(cluster, tab)
            return cluster
        else:
            return self.create_new_cluster(tab)
```

## Clustering Flow

### Adding a Tab

1. **Generate embedding** (if not present)
   ```python
   embedding = openai.embeddings.create(
       model="text-embedding-3-small",
       input=f"{tab.title} {tab.url}"
   )
   ```

2. **Find best matching cluster**
   ```python
   best_similarity = -1
   best_cluster = None

   for cluster in clusters:
       similarity = cosine_similarity(tab.embedding, cluster.centroid)
       if similarity > best_similarity:
           best_similarity = similarity
           best_cluster = cluster
   ```

3. **Assign or create**
   - If `similarity >= threshold`: Add to existing cluster
   - Otherwise: Create new cluster

4. **Update cluster state**
   - Add tab to cluster
   - Update centroid (eager evaluation)
   - Check rename threshold
   - Generate new name if needed

### Removing a Tab

1. **Remove tab from cluster**
   ```python
   cluster.tabs = [t for t in cluster.tabs if t.id != tab_id]
   cluster.tab_count -= 1
   ```

2. **Update centroid**
   ```python
   cluster.update_centroid()  # Prevent ghost cluster
   ```

3. **Check deletion condition**
   ```python
   if cluster.tab_count < 2:
       clusters.remove(cluster)
   ```

4. **NO rename triggered**

## Cluster Naming

Cluster names are generated using GPT-4o-mini based on tab titles and entities.

### Prompt Template

```
You are naming a browser tab group. Generate a concise, descriptive name (2-4 words) that captures the common theme.

Tab titles in this group:
- Neo4j Documentation - Graph Database
- Cypher Query Language Tutorial
- Graph Algorithms in Neo4j

Common entities:
- Neo4j
- Graph Database
- Cypher

Rules:
- Use 2-4 words maximum
- Be specific but concise
- Focus on the main topic or purpose
- Use title case

Generate the name:
```

### Example Names

- "Graph Database Research"
- "React Component Design"
- "Machine Learning Papers"
- "API Documentation"

## Testing

Comprehensive test suite in `tests/test_clustering.py`:

### Test Categories

1. **TabCluster Model Tests**
   - Centroid calculation (single/multiple/empty)
   - Add/remove tab marking centroid dirty
   - Rename threshold
   - Deletion condition

2. **TabClusterer Service Tests**
   - Initialization
   - Cosine similarity
   - Embedding generation
   - Cluster creation
   - Add/remove updates centroid
   - Rename only on additions
   - Cluster deletion

3. **Integration Tests**
   - Ghost cluster prevention
   - Centroid reflects current tabs only

### Running Tests

```bash
# Install dependencies
uv sync --extra dev

# Run tests
uv run pytest tests/test_clustering.py -v

# Run with coverage
uv run pytest tests/test_clustering.py --cov=kg_graph_search.agents
```

## Usage Example

See `examples/clustering_example.py` for a complete demonstration:

```python
from kg_graph_search.agents import Tab, TabClusterer

# Initialize clusterer
clusterer = TabClusterer(
    similarity_threshold=0.75,
    rename_threshold=3,
)

# Create tabs
tab1 = Tab(id=1, url="https://neo4j.com/docs", title="Neo4j Documentation")
tab2 = Tab(id=2, url="https://neo4j.com/cypher", title="Cypher Tutorial")

# Process tabs (automatic clustering)
cluster1 = clusterer.process_tab(tab1)
cluster2 = clusterer.process_tab(tab2)  # Should join cluster1

# Get stats
stats = clusterer.get_cluster_stats()
print(f"Clusters: {stats['total_clusters']}")
print(f"Tabs: {stats['total_tabs']}")

# Remove tab
clusterer.remove_tab_from_cluster(cluster1, tab1.id)
```

## Performance Characteristics

### Time Complexity

- **Embedding generation**: O(1) API call (~100ms)
- **Find best cluster**: O(n × d) where n=clusters, d=embedding_dim
  - Typical: 10 clusters × 1536 dimensions = ~1ms
- **Centroid update**: O(m × d) where m=tabs in cluster
  - Typical: 5 tabs × 1536 dimensions = ~0.1ms
- **Cluster naming**: O(1) API call (~500ms)

### Space Complexity

- **Per tab**: ~6KB (1536 floats × 4 bytes)
- **Per cluster**: ~6KB (centroid) + tab references
- **100 tabs**: ~600KB total

## Configuration

### Environment Variables

```bash
# .env file
OPENAI_API_KEY=sk-...
OPENAI_EMBEDDING_MODEL=text-embedding-3-small
OPENAI_LLM_MODEL=gpt-4o-mini
```

### Clustering Parameters

```python
TabClusterer(
    similarity_threshold=0.75,  # Adjust for stricter/looser clustering
    rename_threshold=3,         # Tabs to add before rename
)
```

## Future Enhancements

### Lazy Centroid Evaluation (Optional)

For performance optimization with large clusters:

```python
class TabCluster:
    _centroid_cache: Optional[list[float]] = None
    _centroid_dirty: bool = True

    @property
    def centroid_embedding(self) -> list[float]:
        """Lazy centroid calculation."""
        if self._centroid_dirty or self._centroid_cache is None:
            self._recalculate_centroid()
        return self._centroid_cache
```

### Hierarchical Clustering

For very large tab collections:
- Top-level clusters (broad topics)
- Sub-clusters (specific subtopics)
- Tree visualization in UI

### Temporal Clustering

Track cluster evolution over time:
- Cluster merge/split events
- Tab migration between clusters
- Historical cluster snapshots

## References

- [PRD.md](../PRD.md) - Product requirements
- [README.md](../README.md) - Project overview
- [examples/clustering_example.py](../examples/clustering_example.py) - Full example
